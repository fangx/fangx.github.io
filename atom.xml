<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fangx</title>
  <subtitle>fangx</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fangx.me/"/>
  <updated>2017-07-11T07:50:13.000Z</updated>
  <id>http://fangx.me/</id>
  
  <author>
    <name>shawn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://fangx.me/%E7%97%85%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%B0%83%E7%A0%94.html"/>
    <id>http://fangx.me/病程管理平台调研.html</id>
    <published>2017-07-11T06:16:13.000Z</published>
    <updated>2017-07-11T07:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>#病程管理平台调研</p>
<p>###调研背景<br>移动医疗在经历一波又一波的浪潮之后，仍然没有真正脱颖而出的公司或者商业模式。现阶段大家的目光更多的关注到线下实体和患者病程管理上来。本文的重点是调研病程管理相关的平台，分析可行性及可能的商业模式。</p>
<p>###目前在做病程管理的产品对比<br>妙健康<br><a href="http://www.healthpoint.cn/archives/57164" target="_blank" rel="external">http://www.healthpoint.cn/archives/57164</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#病程管理平台调研&lt;/p&gt;
&lt;p&gt;###调研背景&lt;br&gt;移动医疗在经历一波又一波的浪潮之后，仍然没有真正脱颖而出的公司或者商业模式。现阶段大家的目光更多的关注到线下实体和患者病程管理上来。本文的重点是调研病程管理相关的平台，分析可行性及可能的商业模式。&lt;/p&gt;
&lt;p&gt;###
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Node.js开发之使用Express框架构建服务端项目</title>
    <link href="http://fangx.me/Node-js%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BD%BF%E7%94%A8Express%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%A1%B9%E7%9B%AE.html"/>
    <id>http://fangx.me/Node-js开发之使用Express框架构建服务端项目.html</id>
    <published>2016-10-28T02:15:13.000Z</published>
    <updated>2016-10-28T02:16:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Express-简介"><a href="#Express-简介" class="headerlink" title="Express 简介"></a>Express 简介</h3><p>Express 是基于 Node.js 平台，快速、开放、极简的 web 开发框架。供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。<br>使用 Express 可以快速地搭建一个完整功能的网站。<br><a id="more"></a></p>
<h5 id="Express-框架核心特性："><a href="#Express-框架核心特性：" class="headerlink" title="Express 框架核心特性："></a>Express 框架核心特性：</h5><ul>
<li>设置中间件来响应 HTTP 请求。</li>
<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>
<li>通过向模板传递参数来动态渲染 HTML 页面。</li>
</ul>
<h3 id="安装Express"><a href="#安装Express" class="headerlink" title="安装Express"></a>安装Express</h3><ol>
<li>创建一个项目文件夹，譬如我创建一个名为TestExpress的文件夹，然后进入到此文件夹。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir TestExpress</div><div class="line">$ cd TestExpress/</div></pre></td></tr></table></figure>
<ol>
<li>通过 npm init 命令为你的应用创建一个 package.json 文件。之前我们了解了package.json的作用，简单说就是npm包管理配置文件，想了解更多的朋友可以去查下资料，这里不多讲解啦~</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure>
<ol>
<li>此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受默认设置即可，下面这个除外：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">entry point: (index.js)</div></pre></td></tr></table></figure>
<ol>
<li><p>这个命令是要你输入应用的入口文件，可以输入app.js（我一般这么用） 或者你所希望的名称，如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。</p>
</li>
<li><p>接下来安装 Express 并将其保存到依赖列表中，如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 –save 参数即可。（安装 Node 模块时，如果指定了 –save 参数，那么此模块将被添加到 package.json 文件中 dependencies 依赖列表中。 然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块。）</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install express --save</div></pre></td></tr></table></figure>
<h3 id="创建一个基本的-Express-应用"><a href="#创建一个基本的-Express-应用" class="headerlink" title="创建一个基本的 Express 应用"></a>创建一个基本的 Express 应用</h3><ol>
<li>进入刚才我们创建的TestExpress文件夹,创建app.js文件,然后将下列代码复制进去：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var express = require(&apos;express&apos;);</div><div class="line">var app = express();</div><div class="line"></div><div class="line">app.get(&apos;/&apos;, function (req, res) &#123;</div><div class="line">  res.send(&apos;Hello World!&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var server = app.listen(3000, function () &#123;</div><div class="line">  var host = server.address().address;</div><div class="line">  var port = server.address().port;</div><div class="line"></div><div class="line">  console.log(&apos;Example app listening at http://%s:%s&apos;, host, port);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>执行命令启动程序,然后在浏览器中打开 <a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a> 并查看输出结果。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node app.js</div></pre></td></tr></table></figure>
<ol>
<li>上面的代码启动一个服务并监听从 3000 端口进入的所有连接请求。他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 404 Not Found。</li>
</ol>
<h3 id="使用Express-应用生成器创建一个应用"><a href="#使用Express-应用生成器创建一个应用" class="headerlink" title="使用Express 应用生成器创建一个应用"></a>使用Express 应用生成器创建一个应用</h3><p>通过应用生成器工具 express 可以快速创建一个应用的骨架。</p>
<ol>
<li>安装Express 应用生成器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install express-generator -g</div></pre></td></tr></table></figure>
<ol>
<li>创建一个应用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ express firstapp</div><div class="line"></div><div class="line">   create : firstapp</div><div class="line">   create : firstapp/package.json</div><div class="line">   create : firstapp/app.js</div><div class="line">   create : firstapp/public</div><div class="line">   create : firstapp/routes</div><div class="line">   create : firstapp/routes/index.js</div><div class="line">   create : firstapp/routes/users.js</div><div class="line">   create : firstapp/public/javascripts</div><div class="line">   create : firstapp/public/images</div><div class="line">   create : firstapp/views</div><div class="line">   create : firstapp/views/index.jade</div><div class="line">   create : firstapp/views/layout.jade</div><div class="line">   create : firstapp/views/error.jade</div><div class="line">   create : firstapp/public/stylesheets</div><div class="line">   create : firstapp/public/stylesheets/style.css</div><div class="line">   create : firstapp/bin</div><div class="line">   create : firstapp/bin/www</div><div class="line"></div><div class="line">   install dependencies:</div><div class="line">     $ cd firstapp &amp;&amp; npm install</div><div class="line"></div><div class="line">   run the app:</div><div class="line">     $ DEBUG=firstapp:* npm start</div></pre></td></tr></table></figure>
<ol>
<li>安装所有依赖包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd firstapp </div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<ol>
<li>启动这个应用（MacOS 或 Linux 平台）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ DEBUG=firstapp npm start</div></pre></td></tr></table></figure>
<p>Windows 平台使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set DEBUG=firstapp &amp; npm start</div></pre></td></tr></table></figure>
<ol>
<li><p>然后在浏览器中打开 <a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a> 网址就可以看到这个应用了。</p>
</li>
<li><p>通过 Express 应用生成器创建的应用一般都有如下目录结构：</p>
</li>
</ol>
<pre><code>.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.jade
    ├── index.jade
    └── layout.jade

7 directories, 9 files
</code></pre><p>至此，我们就学会了最基本的通过Express创建一个Node.js项目。其实通过Express应用生成器创建应用只是众多方法中的一种，你可以不使用它，也可以修改它让它符合你的需求~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Express-简介&quot;&gt;&lt;a href=&quot;#Express-简介&quot; class=&quot;headerlink&quot; title=&quot;Express 简介&quot;&gt;&lt;/a&gt;Express 简介&lt;/h3&gt;&lt;p&gt;Express 是基于 Node.js 平台，快速、开放、极简的 web 开发框架。供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。&lt;br&gt;使用 Express 可以快速地搭建一个完整功能的网站。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://fangx.me/tags/Node-js/"/>
    
      <category term="Express" scheme="http://fangx.me/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Node.js开发之回调和事件循环</title>
    <link href="http://fangx.me/Node-js%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html"/>
    <id>http://fangx.me/Node-js开发之回调和事件循环.html</id>
    <published>2016-10-27T06:47:48.000Z</published>
    <updated>2016-10-27T10:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Node-js回调函数"><a href="#Node-js回调函数" class="headerlink" title="Node.js回调函数"></a>Node.js回调函数</h3><p>通过之前的学习我们了解到，Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。所以我们可以理解为在使用Node.js写程序时会大量的使用异步编程，而Node.js 异步编程的直接体现就是回调。<br><a id="more"></a></p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。<br>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>
<p>举个栗子：我们可以使用Node.js去读取文件，我们知道，读取文件是最基本的IO操作。什么？你不知道IO是什么，好吧，最通俗的理解就是Input与Output的缩写，所以文件读写是很基本的IO操作，至于其它的想深入理解可以去google一下~好啦回归正题，我们想要读取一个文件，而IO操作是比较耗时的，文件大了更可怕，但是不用担心，Node.js异步变成支持我们在读取文件的时候继续去执行其他的操作，我们只需要给文件读取设置一个监听（也就是写个回调函数），当文件读取完之后我们的回调函数就会被调用，我们可以把文件的内容作为回调函数的参数收到。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ol>
<li><p>首先创建一个用户测试的文件 test.txt ,可以随便粘贴一段内容到文件里，我们会用代码把这些内容读取出来，譬如我们写入如下内容：</p>
<p> 好孕帮-助您更快好孕</p>
</li>
<li><p>然后来看一个用同步阻塞方式实现IO操作的代码</p>
</li>
</ol>
<ul>
<li><p>创建 main.js 文件, 代码如下：</p>
<p>  var fs = require(“fs”);<br>  var data = fs.readFileSync(‘input.txt’);<br>  console.log(data.toString());<br>  console.log(“程序执行结束!”);</p>
</li>
<li><p>使用命令运行代码，查看输出结果</p>
<p>  node main.js</p>
</li>
</ul>
<pre><code>好孕帮-助您更快好孕
程序执行结束!
</code></pre><ol>
<li>最后来看一个用异步非阻塞方式实现IO操作的代码</li>
</ol>
<ul>
<li><p>创建 main.js 文件, 代码如下：</p>
<p>  var fs = require(“fs”);</p>
<pre><code>fs.readFile(&apos;input.txt&apos;, function (err, data) {
 if (err) return console.error(err);
 console.log(data.toString());
});
console.log(&quot;程序执行结束!&quot;);
</code></pre></li>
<li><p>使用命令运行代码，查看输出结果</p>
<p>  node main.js</p>
<p>  程序执行结束!<br>  好孕帮-助您更快好孕</p>
</li>
</ul>
<ol>
<li>通过对比第2步和第3步中的输出可以发现,2中的文件读取完之后才结束程序，而3不需要等待文件读取完，就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。 </li>
</ol>
<h3 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js 事件循环</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。<br>通过上面的学习我们了解了什么回调，接下来我们学习Node.js的事件机制，其实Node.js 基本上所有的事件机制都是用设计模式中<a href="http://www.cnblogs.com/Olive116/p/5270948.html" target="_blank" rel="external">观察者模式</a>实现。</p>
<p>Node.js程序是单线程的，我们可以简单的理解程序启动就类似进入到一个while(true)的事件循环，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数。针对服务端而言就是说，每一个 API 都是一个事件，并作为一个独立线程运行，使用异步函数调用，并处理并发。</p>
<h4 id="事件驱动程序模型"><a href="#事件驱动程序模型" class="headerlink" title="事件驱动程序模型"></a>事件驱动程序模型</h4><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>
<p>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）<br>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p>
<p>大概模型如下图：<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/event_loop.jpg" alt="事件驱动程序模型图"></p>
<p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p>
<h3 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>events是Node.js的一个核心模块（如果你还不了解什么是模块，不要着急，后续我们会讲，我们可以简单的理解为模块是Node.js的内置方法，或者用我们之前的理解就是模块就像是一个包，只不过这个包是内置好的）。</p>
<p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。<br>你可以通过require(“events”);来访问该模块。</p>
<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
<p>Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><ul>
<li>创建event.js文件</li>
<li><p>写入如下代码</p>
<p>  // 引入 events 模块<br>  var events = require(‘events’);<br>  // 创建 eventEmitter 对象<br>  var event = new events.EventEmitter();</p>
<p>  event.on(‘test’, function() { </p>
<pre><code>console.log(&apos;test 事件触发&apos;); 
</code></pre><p>  }); </p>
<p>  console.log(‘准备执行事件’); </p>
<p>  setTimeout(function() { </p>
<pre><code>event.emit(&apos;test&apos;); 
</code></pre><p>  }, 1000);</p>
</li>
</ul>
<ul>
<li>运行代码 node event.js ，可以看到控制台先输出 <code>准备执行事件</code> ，然后等待1秒后输出 <code>test 事件触发</code>，这段代码可以看出来我们给event注册了事件test的一个监听器，然后我们通过setTimeout设置一秒后向 event 对象发送事件 test，此时会调用test 的监听器</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Node-js回调函数&quot;&gt;&lt;a href=&quot;#Node-js回调函数&quot; class=&quot;headerlink&quot; title=&quot;Node.js回调函数&quot;&gt;&lt;/a&gt;Node.js回调函数&lt;/h3&gt;&lt;p&gt;通过之前的学习我们了解到，Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。所以我们可以理解为在使用Node.js写程序时会大量的使用异步编程，而Node.js 异步编程的直接体现就是回调。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://fangx.me/tags/Node-js/"/>
    
      <category term="JavaScript" scheme="http://fangx.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Node.js开发之NPM使用介绍</title>
    <link href="http://fangx.me/Node-js%E5%BC%80%E5%8F%91%E4%B9%8BNPM%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://fangx.me/Node-js开发之NPM使用介绍.html</id>
    <published>2016-09-28T05:57:05.000Z</published>
    <updated>2016-09-28T08:35:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="NPM是什么"><a href="#NPM是什么" class="headerlink" title="NPM是什么"></a>NPM是什么</h3><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，用户可以方便的通过npm引入第三方人员开发的包来辅助完成程序开发，开发人员也可以将自己开发的模块功能打包成npm包传到npm中给其他开发人员使用。<br><a id="more"></a><br>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功：</p>
<pre><code>$ npm -v
2.15.5
</code></pre><h3 id="Express是什么"><a href="#Express是什么" class="headerlink" title="Express是什么"></a>Express是什么</h3><p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供一系列强大特性帮助你创建各种Web应用。Express 不对 node.js 已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的功能。丰富的HTTP工具以及来自Connect框架的中间件随取随用，创建强健、友好的API变得快速又简单。想了解更多可以去Express官网查看更多信息<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">Express官网</a></p>
<h3 id="使用-npm-命令安装模块"><a href="#使用-npm-命令安装模块" class="headerlink" title="使用 npm 命令安装模块"></a>使用 npm 命令安装模块</h3><ol>
<li><p>npm 安装 Node.js 模块语法格式如下</p>
<p> $ npm install <module name=""></module></p>
</li>
<li><p>以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express,（npm有特别多好用的包，可以去官网产看<a href="https://www.npmjs.com/" target="_blank" rel="external">传送门</a>）命令如下:</p>
<p> $ npm install express</p>
</li>
<li><p>安装成功之后，express 包就放在了工程目录下的 node_modules 目录中,在程序中使用的时候，我们只需要使用上节课讲到的nodejs required 模块的方式将express引入即可，代码如下：</p>
<p> var express = require(‘express’);</p>
</li>
</ol>
<h3 id="全局安装与本地安装"><a href="#全局安装与本地安装" class="headerlink" title="全局安装与本地安装"></a>全局安装与本地安装</h3><ol>
<li><p>npm 的包安装分为本地安装（local）、全局安装（global）两种,相应的安装命令如下：</p>
<p> npm install <module name="">      # 本地安装<br> npm install <module name=""> -g   # 全局安装</module></module></p>
</li>
<li><p>二者区别</p>
</li>
</ol>
<ul>
<li><p>本地安装</p>
<ol>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ol>
</li>
<li><p>全局安装</p>
<ol>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ol>
<p>可以使用以下命令来查看所有全局安装的模块：</p>
<p>   $ npm ls -g</p>
</li>
</ul>
<h3 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h3><p>可以使用以下命令来卸载 Node.js 模块</p>
<pre><code>$ npm uninstall &lt;Module Name&gt;
</code></pre><p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>
<pre><code>$ npm ls
</code></pre><h3 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h3><p>可以使用以下命令更新模块：</p>
<pre><code>$ npm update &lt;Module Name&gt;
</code></pre><p>##简单总结</p>
<p>npm是一个非常好用的包管理工具，它会伴随着我们的node.js开发，我们可以用npm来管理我们的项目，也可以在npm发现很多让我们的开发变得简单的三方模块。npm还有很多的命令，由于此处只是先入门所以就挑选了几个最简单常用的命令讲解一下，感兴趣的朋友可以去网上查询了解更多，后续的课程中我们也还会有更多npm相关的使用讲解~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;NPM是什么&quot;&gt;&lt;a href=&quot;#NPM是什么&quot; class=&quot;headerlink&quot; title=&quot;NPM是什么&quot;&gt;&lt;/a&gt;NPM是什么&lt;/h3&gt;&lt;p&gt;NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，用户可以方便的通过npm引入第三方人员开发的包来辅助完成程序开发，开发人员也可以将自己开发的模块功能打包成npm包传到npm中给其他开发人员使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://fangx.me/tags/Node-js/"/>
    
      <category term="NPM" scheme="http://fangx.me/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>Node.js开发环境搭建</title>
    <link href="http://fangx.me/Node-js%E5%BC%80%E5%8F%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>http://fangx.me/Node-js开发之环境搭建.html</id>
    <published>2016-09-28T01:20:53.000Z</published>
    <updated>2016-09-28T05:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一个多种语言百花齐放的时代，各种优秀开发语言都占据不小的使用份额，但是近几年JavaScript的使用增长势头明显是最迅猛的，大有超越Java和C的势头，而且随着Node.js的推出，JavaScript不只可以写前端还可以做服务端开发，大有一统Web端开发的苗头。近几年FaceBook推出的React Native ，微信推出的公众号、小程序也在推动着JavaScript增长的浪潮。<br><a id="more"></a><br>本系列课程将带领大家入门Node.js开发，因为最近微信推出的小程序特别火，所以我们的目标就是让大家可以用Node.js实现一个小程序的server端。</p>
<h1 id="储备点基本概念"><a href="#储备点基本概念" class="headerlink" title="储备点基本概念"></a>储备点基本概念</h1><h3 id="Node-js是什么？"><a href="#Node-js是什么？" class="headerlink" title="Node.js是什么？"></a>Node.js是什么？</h3><p>Node.js是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</p>
<p>##安装Node.js</p>
<ol>
<li>去官网下载自己操作系统对应的Node安装文件，作者用的MAC看到的界面如下图  <a href="https://nodejs.org/en/" target="_blank" rel="external">附上下载地址</a></li>
</ol>
<p><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/node_1_1.png" alt="node下载地址"></p>
<p>因为只是入门讲解，所以我们下载稳定版，感兴趣的或者以后深入之后可以下载最新版体验node新特性</p>
<ol>
<li><p>下载之后直接点击安装，如下图：<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/node_1_2.png" alt="node下载地址"><br>一路继续点下去就好~（windows可能涉及到选择安装位置，请自行选择~）</p>
</li>
<li><p>安装完之后，打开终端（命令行）输入 node –version命令确认是否安装成功,效果如下图:<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/node_1_3.png" alt="node下载地址"></p>
</li>
</ol>
<p>##Hello World！<br>下面来学习基于Node.js的第一个程序 – Hello World！</p>
<ol>
<li><p>新创建一个js文件，随便命名为hello.js，然后打开文件，写入如下代码</p>
<p> console.log(“Hello World”);</p>
</li>
</ol>
<p>保存文件。</p>
<ol>
<li>打开终端（命令行） cd 进入创建的hello.js所在的文件夹,然后输入 node hello.js 可以看到终端中输出了Hello World，至此，第一个node.js程序就完成啦~效果如下图：<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/node_1_4.png" alt="node下载地址"></li>
</ol>
<p>##Node.js 创建第一个服务端应用<br>当我们使用Java来写服务端代码时，我们需要Tomcat或者Nigix的HTTP服务器，并配上相应的模块或者框架，这样就可以理解为整个”接收 HTTP 请求并提供 Web 页面”的需求根本不需 要 Java 来处理。不过，对于 Node.js来说，概念完全不同，使用 Node.js 时，不仅仅实现一个应用，同时还实现了整个 HTTP 服务器。也可以理解为 Node.js本身具备了HTTP服务器的功能。</p>
<p>我们创建 Node.js 第一个应用前，先了解下 Node.js 应用是由哪几部分组成的：</p>
<ul>
<li><p>引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。</p>
</li>
<li><p>创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</p>
</li>
<li><p>接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</p>
</li>
</ul>
<h3 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h3><p>创建一个js文件，假如我们创建一个名为server.js的文件，打开文件编辑。</p>
<ol>
<li><p>引入 required 模块<br>我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，代码如下：</p>
<p> var http = require(“http”);</p>
</li>
<li><p>创建服务器</p>
</li>
</ol>
<p>声明服务器监听的端口</p>
<pre><code>var port = 3000;
var hostname = &apos;127.0.0.1&apos;;
</code></pre><p>创建服务器</p>
<pre><code>var server = http.createServer((req, res) =&gt; {
  res.statusCode = 200;
  res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;);
  res.end(&apos;Hello World\n&apos;);
});
</code></pre><p>监听端口</p>
<pre><code>server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre><ol>
<li>启动服务器<br>终端进入server.js所在的文件夹，输入 node server.js，可以看到如下图的效果则第一个node.js服务端应用就创建好了。<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/node_1_5.png" alt="node下载地址"></li>
</ol>
<p><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/node_1_6.png" alt="node下载地址"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是一个多种语言百花齐放的时代，各种优秀开发语言都占据不小的使用份额，但是近几年JavaScript的使用增长势头明显是最迅猛的，大有超越Java和C的势头，而且随着Node.js的推出，JavaScript不只可以写前端还可以做服务端开发，大有一统Web端开发的苗头。近几年FaceBook推出的React Native ，微信推出的公众号、小程序也在推动着JavaScript增长的浪潮。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://fangx.me/tags/Node-js/"/>
    
      <category term="JavaScript" scheme="http://fangx.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>RxJava基础入门系列(三)</title>
    <link href="http://fangx.me/RxJava3.html"/>
    <id>http://fangx.me/RxJava3.html</id>
    <published>2016-03-20T01:39:48.000Z</published>
    <updated>2016-03-21T06:47:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过前两篇的学习我们已经熟悉了RxJava的基本思想，该如何构建、关联Observable（被观察者）和Observer（观察者）这两个角色以及Observable为我们提供的很多好用的方法。打好了基础，下面就一起来体验我感觉RxJava对于android开发的精华所在，更高X格的 <font color="green">线程控制 —— Schedulers</font><br><a id="more"></a></p>
<h2 id="Schedulers是waht"><a href="#Schedulers是waht" class="headerlink" title="Schedulers是waht?"></a>Schedulers是waht?</h2><p>在RxJava 中，Scheduler —— 调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。明白不？就像在android中一般程序是运行在主线程中的，如果我们 new Thread 则可以让部分方法操作运行在独立线程中避免阻塞主线程，而RxJava通过Scheduler封装了new Thread的过程，意味着我们不在需要考虑多线程的问题（爽歪歪~）,当然RxJava做了更多，继续向下看~</p>
<p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Schedulers （调度器）。</p>
<h2 id="RxJava提供了5种调度器："><a href="#RxJava提供了5种调度器：" class="headerlink" title="RxJava提供了5种调度器："></a>RxJava提供了5种调度器：</h2><ul>
<li>.io()</li>
<li>.computation()</li>
<li>.immediate()</li>
<li>.newThread()</li>
<li>.trampoline()</li>
</ul>
<p>让我们一个一个的来看下它们：</p>
<h4 id="Schedulers-io"><a href="#Schedulers-io" class="headerlink" title="Schedulers.io()"></a>Schedulers.io()</h4><p>个人感觉真正开发中最常用的一种调度器，I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>
<p>重点需要注意的是线程池是无限制的，大量的I/O调度操作将创建许多个线程并占用内存。我们需要在性能和简捷两者之间找到一个有效的平衡点。</p>
<h4 id="Schedulers-computation"><a href="#Schedulers-computation" class="headerlink" title="Schedulers.computation()"></a>Schedulers.computation()</h4><p>计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>
<p>它也是许多RxJava方法的默认调度器：buffer() , debounce() , delay() , interval() , sample() , skip()等。</p>
<h4 id="Schedulers-immediate"><a href="#Schedulers-immediate" class="headerlink" title="Schedulers.immediate()"></a>Schedulers.immediate()</h4><p>直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>
<p>它是timeout() , timeInterval() ,以及timestamp()方法默认的调度器。额，可能你不知道这几个方法是啥，我也不知道，不要管，深入之后你会懂的~</p>
<h4 id="Schedulers-newThread"><a href="#Schedulers-newThread" class="headerlink" title="Schedulers.newThread()"></a>Schedulers.newThread()</h4><p>这个调度器正如它所看起来的那样：它为指定任务启动一个新的线程。</p>
<h4 id="Schedulers-trampoline"><a href="#Schedulers-trampoline" class="headerlink" title="Schedulers.trampoline()"></a>Schedulers.trampoline()</h4><p>当我们想在当前线程执行一个任务时，并不是立即，我们可以用.trampoline()将它入队。这个调度器将会处理它的队列并且按序运行队列中每一个任务。它是repeat()和retry()方法默认的调度器。</p>
<p>另外， Android 还有一个专用的  <font color="green">AndroidSchedulers.mainThread()</font>，它指定的操作将在 Android 主线程运行。这个调度器在RxJava包中，大家熟记这个调度器，因为这就是我所说的精华所在，实际开发中会大量用到！</p>
<h2 id="SubscribeOn-and-ObserveOn"><a href="#SubscribeOn-and-ObserveOn" class="headerlink" title="SubscribeOn and ObserveOn"></a>SubscribeOn and ObserveOn</h2><p>我们学到了各种调度器。但是我们如何利用它们来 ​​和Observables一起工作呢？RxJava提供了subscribeOn()方法来用于每个Observable对象。subscribeOn()方法用Scheduler来作为参数并在这个Scheduler上执行Observable调用。</p>
<p>通俗点说就是通过subscribeOn()方法我们可以声明创建（或者说产生）Observable的过程是发生在什么线程中的。</p>
<p>举个例子：</p>
<pre><code>Observable.from(getDataFromDb())
.subscribeOn(Schedulers.io())
.subscribe(new Observer&lt;Chat&gt;() {
    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
    }

    @Override
    public void onNext(Chat chat) {


    }
    });
</code></pre><p>上面的例子表示我们需要从数据库中读取到我们保存的聊天信息，然后转换成Observable对象，然后发射。由于从数据库中读取数据会减慢I/O操作，会阻塞主线程，所以为了优化这个过程我们可以通过subscribeOn(Schedulers.io())声明这个过程发生在独立线程中，这样我们就不会因为操作数据库阻塞主线程啦，是不是很diao~</p>
<p>通过上面的例子我们成功的把阻塞主线程的操作放到独立io线程中执行，但是这是如果我们在Observer 的 onNext方法中操作界面时会报经常碰到的无法再一个非UI线程来修改UI得错误，也就是执行onNext的时候我们仍然处于subscribeOn所创建的线程中，而不是主线程。这是该咋办呢。。。莫慌，RxJava AND RxAndroid已经帮我们考虑好了，这时我们的observeOn()方法就派上用场了~observeOn()方法将会在指定的调度器上返回结果，我们改写上例中的代码如下：</p>
<pre><code>Observable.from(getDataFromDb())
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer&lt;Chat&gt;() {
    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
    }

    @Override
    public void onNext(Chat chat) {


    }
    });
</code></pre><p>就这么简单！这样我们就将Observer的onNext等回调处理拉回到主线程上来了~是不是炒鸡方便！</p>
<h3 id="本篇完"><a href="#本篇完" class="headerlink" title="本篇完"></a>本篇完</h3><p>学完这篇你应该更能体会到RxJava对于android开发的用处了吧，当我们因为阻塞主线程需要创建并发程序时，我们可以毫不犹豫的抛弃各种Thread、Handler、Asynctask,因为RxJava实在是太方便了，有了它不用再考虑实现、同步、线程、平台限制、平台变化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，到这里，我所要讲的入门已经完成了，当然RxJava还有很多很多牛X的东西譬如各种用起来相当爽，让人高潮不断的变换操作以及 与Retrofit 的完美结合等等等，这些之后可能我也会写，如果上述三篇你都能理解，那么我们入门的目的就达到了，现在你已经具备了在实际项目中使用RxJava 的能力，后续你可以在具体使用过程中慢慢的自己去学习RxJava更多更高级的用法~</p>
<h3 id="有兴趣的朋友可以看看我写的开源项目-里面使用了RxJava"><a href="#有兴趣的朋友可以看看我写的开源项目-里面使用了RxJava" class="headerlink" title="有兴趣的朋友可以看看我写的开源项目,里面使用了RxJava"></a>有兴趣的朋友可以看看我写的开源项目,里面使用了RxJava</h3><p><a href="https://github.com/fangx/ZhiHuMVP" target="_blank" rel="external">采用MVP架构的仿知乎APP</a></p>
<h3 id="我们的目标是-：优雅的写代码，愉快的装X"><a href="#我们的目标是-：优雅的写代码，愉快的装X" class="headerlink" title="我们的目标是 ：优雅的写代码，愉快的装X~"></a>我们的目标是 ：优雅的写代码，愉快的装X~</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前两篇的学习我们已经熟悉了RxJava的基本思想，该如何构建、关联Observable（被观察者）和Observer（观察者）这两个角色以及Observable为我们提供的很多好用的方法。打好了基础，下面就一起来体验我感觉RxJava对于android开发的精华所在，更高X格的 &lt;font color=&quot;green&quot;&gt;线程控制 —— Schedulers&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="rxjava" scheme="http://fangx.me/tags/rxjava/"/>
    
      <category term="rxandroid" scheme="http://fangx.me/tags/rxandroid/"/>
    
  </entry>
  
  <entry>
    <title>RxJava基础入门系列(二)</title>
    <link href="http://fangx.me/RxJava2.html"/>
    <id>http://fangx.me/RxJava2.html</id>
    <published>2016-03-13T08:32:25.000Z</published>
    <updated>2016-03-21T06:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://fangx.me/2016/03/06/RxJava1/">上一篇</a> 中讲解一些RxJava的基本概念和创建Observable，Observer对象并通过subscribe关联起来的方法，接下来我们继续深入，学习RxJava为我们提供的一些方便的方法，为我们以后更顺畅的使用RxJava打基础。<br><a id="more"></a></p>
<h1 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h1><h3 id="从列表创建一个Observable"><a href="#从列表创建一个Observable" class="headerlink" title="从列表创建一个Observable"></a>从列表创建一个Observable</h3><h5 id="Observable-from"><a href="#Observable-from" class="headerlink" title="Observable.from()"></a>Observable.from()</h5><p>上一篇中我们知道了可以使用Observable.create()方法来创建一个Observable，不知道你是啥感觉，这种方式我是没办法高潮的~</p>
<p>来来来，让我们来点前戏，RxJava为我们提供了from()函数。使用这个特殊的“创建”函数，我们可以从一个列表中创建一个Observable。Observable将发射出列表中的每一个元素，我们可以通过订阅它们来对这些发出的元素做出响应。</p>
<p>来看个例子，由于项目最近是在做即时通讯的一些东西，我就直接假设我们现在有一个聊天对话列表: List<chat>  chats</chat></p>
<p>假设我们现在想观察这个列表里的所有对话,那么首先要根据 chats 创建一个被观察者 ，我们可以使用Observable的from()函数: </p>
<pre><code>Observable.from(chats)
</code></pre><p>这样我们就得到一个包含chats列表的被观察者即Observable对象，是不是有点太简单了点~</p>
<p>通过查看RxJava的源码我们可以看到Observable.from()方法接收一个Iterable（迭代器）类型的参数，贴下源码：</p>
<pre><code>public final static &lt;T&gt; Observable&lt;T&gt; from(Iterable&lt;? extends T&gt; iterable) {
            return create(new OnSubscribeFromIterable&lt;T&gt;(iterable));
        }
</code></pre><p>其实Observable.from()方法还可以接受数组类型和<a href="http://blog.csdn.net/ghsau/article/details/7451464" target="_blank" rel="external">Future</a>类型的参数，用法类似，可自行尝试~</p>
<p>看到这里你可能会吐槽，说了这么多，有什么卵用，哈哈现在看确实没啥卵用，但是现在我们可是已经get新技能啦，把一个可序列类型的数据结构转换为Observable对象，学会了这种方式，其实我们android开发中很多应用场景都好办多了，不扯淡，继续向下看~</p>
<h3 id="从多个同类型对象创建一个Observable"><a href="#从多个同类型对象创建一个Observable" class="headerlink" title="从多个同类型对象创建一个Observable"></a>从多个同类型对象创建一个Observable</h3><h5 id="Observable-just"><a href="#Observable-just" class="headerlink" title="Observable.just()"></a>Observable.just()</h5><p>我们还可以通过RxJava为我们提供了just()函数来从多个同类型对象创建Observable，代码如下：</p>
<pre><code>Observable.just(chat1, chat2, chat3)
</code></pre><p>通过上面代码创建的Observable在被观察时就会依次发射三个Chat对象</p>
<h3 id="使用我们刚创建的Observable干点大事"><a href="#使用我们刚创建的Observable干点大事" class="headerlink" title="使用我们刚创建的Observable干点大事"></a>使用我们刚创建的Observable干点大事</h3><p>上面我们创建了一个包含List<chat>的Observable，我们可以设想开发中的一个具体使用场景，我们现在收到多条对话，为了提升下次进入聊天页的体验（不每次从服务器拉取数据），我们想把这些对话信息插入到我们的数据库里去好做缓存备份。</chat></p>
<p>对于这种需求，像我这种有追求高逼格的开发人员一般是不会拒绝的，这时我们创建的Observable对象就起到作用了。用RxJava的语言解释这种需求就是观察创建的Observable对象然后从里边一条条的取出对话信息并存起来，实现起来很简单，我们只需要再创建一个观察者Observer，来观察我们创建好的Observable对象就好了~亮代码</p>
<pre><code>Observable.from(chats).subscribe(new Observer&lt;Chat&gt;() {
            @Override
            public void onCompleted() {
                saveDBCompleted();
            }

            @Override
            public void onError(Throwable e) {
                saveDBError();
            }

            @Override
            public void onNext(Chat chat) {
                //存放数据到数据库
                saveDB(chat);
            }
        });
</code></pre><h3 id="吐槽时间"><a href="#吐槽时间" class="headerlink" title="吐槽时间"></a>吐槽时间</h3><p>好吧，我承认这确实不是一件大事，而且你可能会说，你写的这是啥玩意，这种需求我一个for循环就完事了，你搞半天搞出这一堆代码在逗我么!!!~额，我真的没逗你，RxJava这个东西如果按照循序渐进的方式来学的话到这一步确实是这样的。但是不要担心，要知道数据库操作是比较耗时的操作，所以如果你考虑性能的话for循环的方式肯定是太low，所以这时RxJava更牛逼东西 <font color="green">线程控制 —— Scheduler</font> 就会让你高潮啦~</p>
<h3 id="再多几个方法"><a href="#再多几个方法" class="headerlink" title="再多几个方法"></a>再多几个方法</h3><h5 id="创建轮询-interval-方法"><a href="#创建轮询-interval-方法" class="headerlink" title="创建轮询 interval() 方法"></a>创建轮询 interval() 方法</h5><p>在程序开发中我们可能会碰到需要创建一个轮询来完成某件事，最常用的方法可能是开启一个Timer,现在我们有了新的方式，使用Observable的interval方法，相信我，这会让你的代码看上去更优雅，X格更高，用起来炒鸡爽，事例代码：</p>
<pre><code>Observable
.interval(2,TimeUnit.SECONDS)
.subscribe(new Subscriber&lt;Long&gt;() {
            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Long aLong) {

            }
        });
</code></pre><p>interval()函数有两个参数：一个指定两次发射的时间间隔，另一个是用到的时间单位。</p>
<h5 id="延迟发射-timer-方法"><a href="#延迟发射-timer-方法" class="headerlink" title="延迟发射 timer() 方法"></a>延迟发射 timer() 方法</h5><p>开发中我们还可能会碰到一种场景是需要延迟一段时间后去执行某个方法或者去完成某件事情，通常可能会使用Handler.postDelayed方式，但是Handler导致内存泄露的问题实在蛋疼~所以，RxJava都为我们考虑好了，事例代码：</p>
<pre><code>Observable
 .timer(3, TimeUnit.SECONDS)
 .subscribe(new Observer&lt;Long&gt;() {

            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Long number) {
            //勇敢的去干你想干的~

            }
        });
</code></pre><p>上述方法会在三秒后发射一个0，然后就完成了，你所要做的就是在onNext中去做你想做的事。</p>
<p>其实timer还有更高级的用法,如下：</p>
<pre><code>Observable
.timer(3, 2,TimeUnit.SECONDS)
.subscribe(new Observer&lt;Long&gt;() {

            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Long number) {
            }
        });
</code></pre><p>上面的代码中只多传了一个参数，实现的效果是会在三秒后开启一个轮询程序，相当于延迟3秒执行的interval()版本。</p>
<h5 id="指定范围发射-range-方法"><a href="#指定范围发射-range-方法" class="headerlink" title="指定范围发射 range() 方法"></a>指定范围发射 range() 方法</h5><p>如果我们想从一个指定的数字a开始发射b个数字，则可以使用range() 方法,参数可以有两个，第一个是开始点，第二个是想要发射的数字个数。事例代码：</p>
<pre><code>Observable
.range(5,3)
.subscribe(new Observer&lt;Chat&gt;() {...});
</code></pre><p>上面的代码会输出5，6，7</p>
<h5 id="重复发射-repeat-方法"><a href="#重复发射-repeat-方法" class="headerlink" title="重复发射 repeat() 方法"></a>重复发射 repeat() 方法</h5><p>如果我们想把列表中的聊天数据重复遍历多次，则可以使用repeat() 方法,参数是想要重复的次数。事例代码：</p>
<pre><code>Observable
 .from(chats)
 .repeat(3)
 .subscribe(new Observer&lt;Chat&gt;() {...});
</code></pre><p>上面的代码会把chats重复发送三次</p>
<p>好了，第二篇到此结束，到这里关于Observable的理解应该更深入了，也可以更优雅的创建Observable对象了，还get了很多实用的技能，再也不用被使用timer,hanler等方式时各种恶心的问题所困扰啦，下一篇讲讲 <font color="green">线程控制 —— Scheduler</font> 绝对高潮到尖叫</p>
<h3 id="我们的目标是-：优雅的写代码，愉快的装X"><a href="#我们的目标是-：优雅的写代码，愉快的装X" class="headerlink" title="我们的目标是 ：优雅的写代码，愉快的装X~"></a>我们的目标是 ：优雅的写代码，愉快的装X~</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://fangx.me/2016/03/06/RxJava1/&quot;&gt;上一篇&lt;/a&gt; 中讲解一些RxJava的基本概念和创建Observable，Observer对象并通过subscribe关联起来的方法，接下来我们继续深入，学习RxJava为我们提供的一些方便的方法，为我们以后更顺畅的使用RxJava打基础。&lt;br&gt;
    
    </summary>
    
    
      <category term="rxjava" scheme="http://fangx.me/tags/rxjava/"/>
    
      <category term="rxandroid" scheme="http://fangx.me/tags/rxandroid/"/>
    
  </entry>
  
  <entry>
    <title>RxJava基础入门系列(一)</title>
    <link href="http://fangx.me/RxJava1.html"/>
    <id>http://fangx.me/RxJava1.html</id>
    <published>2016-03-06T08:32:25.000Z</published>
    <updated>2016-03-21T06:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RxJava应该是近两年最流行的Android技术之一了，看到越来越多的Android开发者被RxJava搞到高潮，发出RxJava真是太爽了的感（shen）叹（yin）时，我自然也很想去感受一番~<br><a id="more"></a><br>RxJava的响应式编程思想对于习惯了使用命令式编程语言的Android开发者来说确实有点难以入门，我也是翻来覆去断断续续的鼓捣了一个多月，终于达到了入门境界，可以窥探她里面美丽的风景，发现，真的很美~</p>
<h1 id="还是前言"><a href="#还是前言" class="headerlink" title="还是前言"></a>还是前言</h1><p>额，这一系列的文章是我从一个小白到入门的经验记录，适合想入门的RxJava小白同学阅读，当然大神如果愿意花些宝贵的时间帮我指点指点，小弟感激不尽！</p>
<p>废话太多~接下来，我将从一个Android开发者的角度，用最直白的语言和最通俗易懂的demo来讲述我的入门过程，希望大家看过之后能够得以入门，至少能够恍然大悟，发出RxJava真的很NB的感叹~</p>
<h1 id="储备点基本概念"><a href="#储备点基本概念" class="headerlink" title="储备点基本概念"></a>储备点基本概念</h1><h3 id="RxJava是什么？"><a href="#RxJava是什么？" class="headerlink" title="RxJava是什么？"></a>RxJava是什么？</h3><p>首先呈上RxJava和RxAndroid的源码Github链接</p>
<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a></p>
<p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid</a></p>
<p>额，点进去看了？看懂了？没看懂就对了，看懂了的话你可以右上角了，反正我是看不懂~以我入门级的理解，RxJava是一个实现异步操作的库，如果你不能理解，那以我的语言表达能力更通俗点更android的解释就是RxJava是一个可以让你把一些耗时阻塞主线程的操作放到独立线程中执行并且在操作执行完成后又可以通过与RxAndroid配合切回到主线程（UI线程）完成后续操作的一套东西（好吧，这其实是我目前能感觉到的RxJava对于android最有意义的地方），当然RxJava还提供了很多很好用的函数，可以让你在做一些复杂操作时爽翻天~</p>
<h3 id="为什么是RxJava？"><a href="#为什么是RxJava？" class="headerlink" title="为什么是RxJava？"></a>为什么是RxJava？</h3><p>android能够实现异步的方式很多Thread、Handler、AsyncTask等,这些方式相信大家都用过，而且我感觉以我的渣渣表达能力在你还没有真正搞懂RxJava怎么用的时候，我解释半天你也不会明白的。。。所以<br>我现在能告诉你的只有一句话它们真的都没RxJava爽。</p>
<p>RxJava入门有点难首先一点就是要理解的概念挺多，所以不要烦，耐心把下面几点理解、理解、理解~</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>因为RxJava的异步是通过一种扩展的观察者模式来实现的,所以我们需要先了解观察者模式的一些基本概念。相信作为一个android开发者对于观察者模式应该不陌生，最简单的按钮点击事件OnClickListener<br>就是观察者模式的典型应用。通过OnClickListener给View设置一个观察者，观察View点击状态变化，<br>当按钮被点击自动给予观察者一个反馈去执行后续操作。对于观察者模式最经典的解释是报社和读者，通过观察者模式又被称作发布-订阅模式不难理解，读者交钱预定报社发布的报纸，当报社有新的报纸发行时会送到读者手中~</p>
<h3 id="RxJava观察者模式工具包"><a href="#RxJava观察者模式工具包" class="headerlink" title="RxJava观察者模式工具包"></a>RxJava观察者模式工具包</h3><p>在RxJava的世界里，我们有四种角色：</p>
<ol>
<li>Observable  （被观察者）</li>
<li>Observer    （观察者）</li>
<li>Subscriber  （订阅者）</li>
<li>Subject    （事件）</li>
</ol>
<p>Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。</p>
<p>这里Observer和Subscriber容易让人迷惑，其实Subscriber 对 Observer 接口进行了一些扩展，他们的基本使用方式一样，实质上，在 RxJava 的 subscribe（订阅） 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用，所以可以简单理解为一类东西。</p>
<h1 id="OK，High起来"><a href="#OK，High起来" class="headerlink" title="OK，High起来"></a>OK，High起来</h1><p>为了帮助你更好的理解，我决定用奥运赛场上的射击比赛的例子来讲解接下来的内容~</p>
<h3 id="创建一个Observable"><a href="#创建一个Observable" class="headerlink" title="创建一个Observable"></a>创建一个Observable</h3><p>Observable即被观察者，即射击选手~</p>
<p>RxJava提供Observable.create()方法来创建一个观察者，创建的时候需要传入一个OnSubscribe对象。</p>
<p>OnSubscribe对象的作用是当Observable被订阅（即有观察者想要观察被观察者）的时候，OnSubscribe里的call()方法会被自动调用，执行方法里的操作。</p>
<p>用我们的方式理解就是，当裁判一声令下，射击选手就开始射击射击射击…结束射击~正如下面代码中显示的一样~</p>
<pre><code>Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) {
        //开始射击
        subscriber.onNext(&quot;第一发&quot;);
        subscriber.onNext(&quot;第二发&quot;);
        subscriber.onNext(&quot;第三发&quot;);
        subscriber.onNext(&quot;第四发&quot;);
        subscriber.onNext(&quot;第五发&quot;);
        //完成射击
        subscriber.onCompleted();
    }
});
</code></pre><h3 id="创建一个Observer"><a href="#创建一个Observer" class="headerlink" title="创建一个Observer"></a>创建一个Observer</h3><p>Observer即观察者，即裁判~</p>
<p>RxJava中Observer是一个接口，有三个方法onNext，onCompleted，onError。三个方法会在观察的过程中被调用，当观察者开始观察被观察者时，首先会触发onNext方法，当观察结束时触发onCompleted方法，当观察过程中出现异常时触发onError方法。</p>
<p>继续用我们的例子解释，有了裁判，这时比赛开始裁判观察射击运动员的射击情况，运动员每射击一次裁判的onNext方法都会被调用一次记录，如果运动员射击的过程很顺利，则会一直调用onNext到射击完成调用onCompleted结束射击过程。但是这个过程中可能是会出现问题的~譬如运动员比赛过程中想不开，拿枪把自己给蹦了，额，这时就会触发我们的onError方法~</p>
<pre><code>Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {
    @Override
    public void onNext(String s) {
        Log.d(&quot;fx------&quot;, s);
    }

    @Override
    public void onCompleted() {
        Log.d(&quot;fx------&quot;, &quot;射击完成&quot;);
    }

    @Override
    public void onError(Throwable e) {
       Log.d(&quot;fx------&quot;, e.getMessage());
    }
};
</code></pre><h3 id="连接起来"><a href="#连接起来" class="headerlink" title="连接起来"></a>连接起来</h3><p>现在我们已经有了Observable和Observer，接下来就考虑怎么把二者关联起来~ Observable类中提供了subscribe()方法，接收一个observer对象作为参数，使用这个方法我们就可以直接完成Observable和Observer的关联，实现一个最简单的RxJava链式程序~</p>
<p>代码形式如下：</p>
<pre><code>observable.subscribe(observer);
</code></pre><h2 id="入门完成"><a href="#入门完成" class="headerlink" title="入门完成"></a>入门完成</h2><p>如果以上的内容对于你都没有难度，那你离入门已经很近啦~后续的部分会讲解一些RxJava提供的更多好用的方法，以及RxJava在Android实际项目中具体使用例子~</p>
<h3 id="我们的目标是-：优雅的写代码，愉快的装X"><a href="#我们的目标是-：优雅的写代码，愉快的装X" class="headerlink" title="我们的目标是 ：优雅的写代码，愉快的装X~"></a>我们的目标是 ：优雅的写代码，愉快的装X~</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;RxJava应该是近两年最流行的Android技术之一了，看到越来越多的Android开发者被RxJava搞到高潮，发出RxJava真是太爽了的感（shen）叹（yin）时，我自然也很想去感受一番~&lt;br&gt;
    
    </summary>
    
    
      <category term="rxjava" scheme="http://fangx.me/tags/rxjava/"/>
    
      <category term="rxandroid" scheme="http://fangx.me/tags/rxandroid/"/>
    
  </entry>
  
  <entry>
    <title>教你如何使用Shadowsocks优雅眺望墙外风景</title>
    <link href="http://fangx.me/shadowsocks.html"/>
    <id>http://fangx.me/shadowsocks.html</id>
    <published>2016-02-28T02:30:08.000Z</published>
    <updated>2016-03-08T05:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将一步步教你如何使用亚马逊云服务AWS+Shadowsocks搭建自己的代理服务，轻松方便眺望墙外风景，再也不用忍受VPN被封掉，插件不好用，花钱买了翻墙服务不稳定等坑爹情况，拥有自己的代理服务，让我们来一起装逼一起飞。<br><a id="more"></a></p>
<h2 id="为什么要使用AWS？"><a href="#为什么要使用AWS？" class="headerlink" title="为什么要使用AWS？"></a>为什么要使用AWS？</h2><p>因为免费用一年。。。。。。</p>
<h2 id="什么是Shadowsocks？"><a href="#什么是Shadowsocks？" class="headerlink" title="什么是Shadowsocks？"></a>什么是Shadowsocks？</h2><p>Shadowsocks（中文名称：影梭）是使用Python等语言开发的、基于Apache许可证开源的代理软件。Shadowsocks使用socks5代理，用于保护网络流量。在中国大陆被广泛用于突破防火长城（GFW），以浏览被封锁的内容。</p>
<p>Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署在支持Python的服务器上面，然后通过客户端连接并创建本地代理。此外用户也可以选择购买基于Shadowsocks的商业服务，以获得更加稳定可靠的服务，或者免去自行部署的麻烦。—–来自<a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="external">维基百科</a> </p>
<h2 id="为什么要使用Shadowsocks？"><a href="#为什么要使用Shadowsocks？" class="headerlink" title="为什么要使用Shadowsocks？"></a>为什么要使用Shadowsocks？</h2><p>这么多年与GFW的抗争中，先后使用了GoAgent，红杏插件，土行孙等或免费或付费的工具，但总是会遇到诸多问题，要么用着用着不能用了，要么很不稳定，而且有的要付费，付费没问题，用的不爽问题就很大啦~额~</p>
<p>Shadowsocks在广大翻墙群众中非常流行，有许多基于Shadowsocks搭建的付费VPN服务，用它在自己服务器上搭建代理的朋友则是更多。其影响力之大，以至于官方都坐不住了，向原作者clowwindy施加压力，使得作者删除了在Github上的代码库。</p>
<p>基于此，遂下定决心搭一个自己的Shadowsocks代理服务。</p>
<h2 id="第一步申请亚马逊云服务AWS"><a href="#第一步申请亚马逊云服务AWS" class="headerlink" title="第一步申请亚马逊云服务AWS"></a>第一步申请亚马逊云服务AWS</h2><ol>
<li><a href="http://aws.amazon.com/cn/" target="_blank" rel="external">点击打开AWS官网</a><br> 如下图点击注册：<br> <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_1.png" alt="AWS主页图"></li>
<li>注册账号<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_2.png" alt="注册页面"><br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_3.png" alt="注册页面"><br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_4.png" alt="注册页面"></li>
<li>认证流程<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_5.png" alt="注册页面"><br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_6.png" alt="注册页面"><br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_7.png" alt="注册页面"><br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_8.png" alt="注册页面"><br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_9.png" alt="注册页面"></li>
<li>认证完成登陆控制台<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_10.png" alt="注册页面"></li>
</ol>
<h2 id="第二步创建EC2"><a href="#第二步创建EC2" class="headerlink" title="第二步创建EC2"></a>第二步创建EC2</h2><ol>
<li>登陆控制台点击如图EC2<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_11.png" alt="创建EC2"></li>
<li>进入EC2控制面板如下图点击启动实例<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_28.png" alt="创建EC2">  </li>
<li><p>根据步骤一步步创建实例（记得保存好秘钥，连接服务器时需要用到~）<br> <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_13.png" alt="创建EC2"><br> <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_14.png" alt="创建EC2"><br> <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_15.png" alt="创建EC2"><br> <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_16.png" alt="创建EC2"><br> <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_17.png" alt="创建EC2"></p>
<p>至此，服务器创建完成，下面就连接进去~</p>
</li>
</ol>
<h2 id="第三步连接服务器安装配置Shadowsocks"><a href="#第三步连接服务器安装配置Shadowsocks" class="headerlink" title="第三步连接服务器安装配置Shadowsocks"></a>第三步连接服务器安装配置Shadowsocks</h2><p>由于作者使用的是MAC，所以以下都是使用MAC讲解连接服务器，如果是windows用户可以使用putty连接</p>
<ol>
<li>首先cd到下载的秘钥目录执行命令修改文件权限<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_18.png" alt="登陆服务器"></li>
<li><p>执行命令: ssh -i 你命名的秘钥名.pem ubuntu@你的服务器节点ip</p>
<p>服务器节点ip可从下图中找到，即共有DNS<br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_19.png" alt="登陆服务器"><br><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_20.png" alt="登陆服务器"></p>
</li>
<li><p>至此连接进服务器，然后安装shadowsocks依赖</p>
<ul>
<li>获取root权限： sudo -s </li>
<li>更新apt-get： apt-get update </li>
<li>安装python包管理工具pip：apt-get install python-pip </li>
<li>安装shadowsocks：pip install shadowsocks</li>
</ul>
</li>
<li><p>配置shadowsocks  使用vi编辑，不会的同学可以搜索一下~<br>vi /etc/shadowsocks.json</p>
<ul>
<li>单用户配置</li>
</ul>
</li>
</ol>
<p>{</p>
<pre><code>&quot;server&quot;:&quot;0.0.0.0&quot;,

&quot;server_port&quot;:你的端口,

&quot;local_address&quot;: &quot;127.0.0.1&quot;,

&quot;local_port&quot;:1080,

&quot;password&quot;:&quot;你的密码&quot;,

&quot;timeout&quot;:300,

&quot;method&quot;:&quot;aes-256-cfb&quot;,

&quot;fast_open&quot;: false,

&quot;workers&quot;: 1
</code></pre><p>}</p>
<ul>
<li>多用户多端口</li>
</ul>
<p>{</p>
<pre><code>&quot;server&quot;:&quot;0.0.0.0&quot;,

&quot;local_address&quot;:&quot;127.0.0.1&quot;,

&quot;local_port&quot;:1080,

&quot;port_password&quot;:{

     &quot;8877&quot;:&quot;密码&quot;,

     &quot;8888&quot;:&quot;密码&quot;,

     &quot;8899&quot;:&quot;密码&quot;,

},

&quot;timeout&quot;:300,

&quot;method&quot;:&quot;aes-256-cfb&quot;,

&quot;fast_open&quot;: false
</code></pre><p>}</p>
<ol>
<li><p>开启shadowsocks: ssserver -c /etc/shadowsocks.json -d start</p>
</li>
<li><p>开启AWS入站端口 (新添加的规则中端口对应的是第四步中你配置的端口~)<br>  <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_21.png" alt="开启AWS入站端口"><br>  <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_22.png" alt="开启AWS入站端口"><br>  <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_23.png" alt="开启AWS入站端口"></p>
</li>
</ol>
<p>至此服务器配置已全部结束，下面就可以在各种客户端使用了</p>
<h2 id="第四步配置客户端"><a href="#第四步配置客户端" class="headerlink" title="第四步配置客户端"></a>第四步配置客户端</h2><h3 id="MAC配置"><a href="#MAC配置" class="headerlink" title="MAC配置"></a>MAC配置</h3><ol>
<li><a href="http://pan.baidu.com/s/1kUueye7" target="_blank" rel="external">点击下载ShadowsocksX客户端</a> </li>
<li>下载后解压安装，此处可能会受到MAC系统安装控制点困扰可以打开系统偏好设置-&gt;安全性与隐私中允许安装此应用</li>
<li><p>安装成功后会看到下图图标</p>
<p> <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_24.png" alt="开启AWS入站端口"></p>
</li>
<li><p>点击运行会看到桌面右上角出现下图标识</p>
<p><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_25.png" alt="开启AWS入站端口"></p>
</li>
<li><p>点击图标选择服务器-&gt;打开服务器设定然后填写如下图</p>
<p><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_26.png" alt="开启AWS入站端口"></p>
<p><img src="http://fxblog.oss-cn-beijing.aliyuncs.com/aws_27.png" alt="开启AWS入站端口"></p>
</li>
<li><p>填写完成后点击右上角小飞机图标打开shadowsocks（建议选择自动代理模式，这样墙内的网站不会走代理~）</p>
</li>
</ol>
<h3 id="Windows配置"><a href="#Windows配置" class="headerlink" title="Windows配置"></a>Windows配置</h3><ol>
<li><a href="http://pan.baidu.com/s/1dDTmj65" target="_blank" rel="external">点击下载ShadowsocksX客户端</a> </li>
<li>其他配置和MAC类似~</li>
</ol>
<h3 id="IOS配置"><a href="#IOS配置" class="headerlink" title="IOS配置"></a>IOS配置</h3><ol>
<li>在Appstore搜索下载Shadowsocks</li>
<li>设置自己的服务器,设置方法同上</li>
<li>由于IOS版只支持浏览器，有其他需求的可以搭建 Strongswan，实现在 iOS 上连接 VPN，<a href="http://www.jianshu.com/p/2f51144c35c9" target="_blank" rel="external">参考链接</a> </li>
</ol>
<h3 id="Android配置"><a href="#Android配置" class="headerlink" title="Android配置"></a>Android配置</h3><ol>
<li><a href="http://pan.baidu.com/s/1dEcF2It" target="_blank" rel="external">点击下载APK文件</a></li>
<li>下载后无需root，设置好服务器和帐号信息后即可直接使用。与iOS版本不同，android版是以VPN的方式运行的，也就是说不仅支持浏览器，而且支持其他App</li>
</ol>
<h4 id="如果我的文章真的给你带来帮助，可以扫描二维码打赏我哦（一毛就好-只是想验证下我写的东西是否真的能够有人愿意买单-）"><a href="#如果我的文章真的给你带来帮助，可以扫描二维码打赏我哦（一毛就好-只是想验证下我写的东西是否真的能够有人愿意买单-）" class="headerlink" title="如果我的文章真的给你带来帮助，可以扫描二维码打赏我哦（一毛就好~只是想验证下我写的东西是否真的能够有人愿意买单~）"></a>如果我的文章真的给你带来帮助，可以扫描二维码打赏我哦（一毛就好~只是想验证下我写的东西是否真的能够有人愿意买单~）</h4><p> <img src="http://fxblog.oss-cn-beijing.aliyuncs.com/weixin_pay.JPG" alt="微信打赏"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将一步步教你如何使用亚马逊云服务AWS+Shadowsocks搭建自己的代理服务，轻松方便眺望墙外风景，再也不用忍受VPN被封掉，插件不好用，花钱买了翻墙服务不稳定等坑爹情况，拥有自己的代理服务，让我们来一起装逼一起飞。&lt;br&gt;
    
    </summary>
    
    
      <category term="shadowsocks" scheme="http://fangx.me/tags/shadowsocks/"/>
    
      <category term="翻墙" scheme="http://fangx.me/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>好孕帮</title>
    <link href="http://fangx.me/haoyunbang.html"/>
    <id>http://fangx.me/haoyunbang.html</id>
    <published>2015-08-01T02:30:08.000Z</published>
    <updated>2016-03-04T10:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.haoyunbang.cn/" target="_blank" rel="external">助您更快好孕!</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.haoyunbang.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;助您更快好孕!&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
